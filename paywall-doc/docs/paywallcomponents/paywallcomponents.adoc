== Paywall Core Components

The Paywall framework is built up of a set of core components controlling the payment flow and
most of them are customizable. This chapter goes through the core parts of these components that are not
directly Spring Framework specific.

First are the most basic concepts in Paywall Framework, and that are required when using the framework are:

* _PaymentHandler_, that creates, updates and persist _PaymentData_.
* _PaymentData_, value object of a given payment state.
* _@PaymentRequired_, annotation that is set on API services that should trigger a payment flow.

Then are the concept _PaymentFlow_ described, that is in charge of directing the flow between
the different components.

Finally are other core components discussed, such as _LightningHandler_ used to communicate with the lightning node, and
_CurrencyConverter_ that is in charge of converting between FIAT and Crypto currency if needed.

[[paymenthandler]]
=== Payment Handler

A PaymentHandler manages Orders, Invoices and Settlements in a payment flow and every application using Paywall
framework is required to implement one. The class is responsible to create and persist a value object of type
PaymentData.

A PaymentData that can be of different types depending on the level of control of the actual payment flow wanted or
the what types of payment related data that needs to be persisted.

==== Implementing a Payment Handler using Spring Framework

Using the Spring Framework, the easiest way to implement the payment handler is to create a class extending
_org.lightningj.paywall.spring.SpringPaymentHandler_ and implement the following three methods:

newPaymentData:: Method that should generate a new PaymentData. The method receives a newly generated preImageHash, used
to uniquely identify the payment flow, and an OrderRequest, containing data from PaymentRequired annotation. This is the
first call in a payment flow and the implementation should for example look up the order amount from the article id,
units and other options in the order request. The generated PaymentData should be at least MinimalPaymentData with
preImageHash and orderedAmount set. It is recommended that the PaymentData is persisted in this call but could
be skipped for performance in certain payment flows.

findPaymentData:: Method used by the paywall framework to lookup a PaymentData from a preImageHash.

updatePaymentData:: Method called on update events about a given payment data. This could be when the payment is added
as invoice in LND and contains complementary data or when the invoice was settled and has the _settled_ flag set along
with the settled amount (depending on the type of PaymentData used in PaymentHandler). The implementing method should at
least persist the updated payment data. See table <<paymenteventtypes, Available Payment Event Types>> for list of
different _PaymentEventType_ that might occur.


.Table Available Payment Event Types
|===
| Type | Description

| ORDER_CREATED
| Event signaling a order was created. This event is never sent to updatePaymentData.

| INVOICE_CREATED
| Event signaling that a payments invoice have been created by lightning handler.

| INVOICE_SETTLED
| Event signaling that a invoice have been settled.

| REQUEST_EXECUTED
| Event signaling that a payed request has been executed. Only used for payment
  flows with payPerRequest flag set.

|===

Below is an excerpts of the required methods to implement:

[source, java]
-----------------------------
    /**
     * Method that should generate a new PaymentData for a given order request.
     * This is the first call in a payment flow and the implementation should
     * look up the order amount from the article id, units and other options in
     * the order request.
     *
     * The generated PaymentData should be at least MinimalPaymentData with preImageHash
     * and orderedAmount set.
     *
     * It is recommended that the PaymentData is persisted in this call but could
     * be skipped for performance in certain payment flows.
     *
     * @param preImageHash the unique preImageHash used to identify a payment flow
     *                     withing a lightning payment.
     * @param orderRequest the specification of the payment data that should be created calculated
     *                     from data in the PaymentRequired annotation.
     * @return a newly generated PaymentData signaling a new payment flow used to
     * create an Order value object.
     * @throws IOException if communication exception occurred in underlying components.
     * @throws InternalErrorException if internal exception occurred generating new payment data.
     */
    protected abstract PaymentData newPaymentData(byte[] preImageHash, OrderRequest orderRequest) throws IOException, InternalErrorException;

    /**
     * Method to lookup a payment data in the payment handler.
     *
     * @param preImageHash the unique preImageHash used to identify a payment flow
     *                     withing a lightning payment.
     * @return return related payment data or null if not found.
     * @throws IOException if communication exception occurred in underlying components.
     * @throws InternalErrorException if internal exception occurred fetching related payment data.
     */
    protected abstract PaymentData findPaymentData(byte[] preImageHash) throws IOException, InternalErrorException;

    /**
     * Method called on update events about a given payment data. This could be when
     * the payment is added as invoice in LND and contains complementary data or when
     * the invoice was settled and contains settled flag set and settled amount and date
     * (depending on the type of PaymentData used in PaymentHandler).
     *
     * The related payment data (using preImageHash as unique identifier) is automatically
     * looked up and the implementing method should at least persist the updated data.
     *
     * @param type the type of event such as INVOICE_CREATED or INVOICE_SETTLED.
     * @param paymentData the payment data to update and persist.
     * @param context the latest known state of the lightning handler.  Null if no known state exists.
     * @throws IOException if communication exception occurred in underlying components.
     * @throws InternalErrorException if internal exception occurred updating related payment data.
     */
    protected abstract void updatePaymentData(PaymentEventType type, PaymentData paymentData,
                                          LightningHandlerContext context) throws IOException, InternalErrorException;


-----------------------------

Below is an example implementation for Spring Framework, that assumes you have Spring Data Repository for a
FullPaymentData implementation (see <<paymentdata,PaymentData section>> ), and that supports _payPerRequest_ annotated
services. It also assumes there exists a Spring Data Repository for the Article Ids specified in @PaymentRequired
annotation to look up price for specified Article Id.

Using Spring it is important to add the class as a component with name _paymentHandler_ using the
@Component("paymentHandler") annotation on the class level.

[source, java]
-----------------------------
/**
 * Demo implementation of a Payment Handler extending SpringPaymentHandler.
 *
 * It creates DemoPaymentData that implements the PerRequestPaymentData interface. (In order to demonstrate
 * support for both request that's valid for a period of time and for a specific request.)
 * by first looking up the article id order (generated by the @PaymentRequired annotation).
 * Then checks the price of the article in ArticleData table to calculate the ordered amount.
 *
 * It also implements the lookup by preImageHash method and update payment data methods by calling
 * related methods in the DemoPaymentDataRepository.
 *
 */
@Component("paymentHandler")
public class DemoPaymentHandler extends SpringPaymentHandler {

    @Autowired
    DemoFullPaymentDataRepository demoPaymentDataRepository;

    @Autowired
    ArticleDataRepository articleDataRepository;

    /**
     * Method that should generate a new PaymentData for a given order request.
     * This is the first call in a payment flow and the implementation should
     * look up the order amount from the article id, units and other options in
     * the order request.
     * <p>
     * The generated PaymentData should be at least MinimalPaymentData with preImageHash
     * and orderedAmount set.
     * <p>
     * It is recommended that the PaymentData is persisted in this call but could
     * be skipped for performance in certain payment flows.
     *
     * @param preImageHash the unique preImageHash used to identify a payment flow
     *                     withing a lightning payment.
     * @param orderRequest the specification of the payment data that should be created calculated
     *                     from data in the PaymentRequired annotation.
     * @return a newly generated PaymentData signaling a new payment flow used to
     * create an Order value object.
     * @throws IOException            if communication exception occurred in underlying components.
     * @throws InternalErrorException if internal exception occurred generating new payment data.
     */
    @Override
    protected PaymentData newPaymentData(byte[] preImageHash, OrderRequest orderRequest) throws IOException, InternalErrorException {
        try{
            DemoFullPaymentData demoPaymentData = new DemoFullPaymentData();
            demoPaymentData.setPreImageHash(preImageHash);
            demoPaymentData.setPayPerRequest(orderRequest.isPayPerRequest());

            ArticleData articleData = articleDataRepository.findByArticleId(orderRequest.getArticleId());
            if(articleData == null){
                throw new InternalErrorException("Internal error creating payment data, article id " + orderRequest.getArticleId() + " doesn't exist in database.");
            }
            long orderPrice = articleData.getPrice() * orderRequest.getUnits(); // Price in satoshis.
            demoPaymentData.setOrderAmount(new BTC(orderPrice));

            demoPaymentDataRepository.save(demoPaymentData);
            return demoPaymentData;
        }catch(Exception e){
            if(e instanceof InternalErrorException){
                throw e;
            }
            throw new InternalErrorException("Error occurred saving DemoPaymentData to database: " + e.getMessage(),e);
        }
    }

    /**
     * Method to lookup a payment data in the payment handler.
     *
     * @param preImageHash the unique preImageHash used to identify a payment flow
     *                     withing a lightning payment.
     * @return return related payment data or null if not found.
     * @throws InternalErrorException if internal exception occurred fetching related payment data.
     */
    @Override
    protected PaymentData findPaymentData(byte[] preImageHash) throws InternalErrorException {
        try{
          return demoPaymentDataRepository.findByPreImageHash(Base58.encodeToString(preImageHash));
        }catch(Exception e){
          throw new InternalErrorException("Error occurred fetching DemoPaymentData from database: " + e.getMessage(),e);
        }
    }

    /**
     * Method called on update events about a given payment data. This could be when
     * the payment is added as invoice in LND and contains complementary data or when
     * the invoice was settled and contains settled flag set and settled amount and date
     * (depending on the type of PaymentData used in PaymentHandler).
     * <p>
     * The related payment data (using preImageHash as unique identifier) is automatically
     * looked up and the implementing method should at least persist the updated data.
     *
     * @param type        the type of event such as INVOICE_CREATED or INVOICE_SETTLED.
     * @param paymentData the payment data to update and persist.
     * @param context     the latest known state of the lightning handler.  Null if no known state exists.
     * @throws InternalErrorException if internal exception occurred updating related payment data.
     */
    @Override
    protected void updatePaymentData(PaymentEventType type, PaymentData paymentData, LightningHandlerContext context) throws InternalErrorException {
        try {
            assert paymentData instanceof DemoFullPaymentData;
            demoPaymentDataRepository.save((DemoFullPaymentData) paymentData);
        }catch(Exception e){
            throw new InternalErrorException("Error occurred updating DemoPaymentData to database: " + e.getMessage(),e);
        }
    }
}
-----------------------------



[[paymentdata]]
==== Payment Data

PaymentData is a value object, usually stored in a database, that the _PaymentHandler_ manages. There exists
several interfaces to choose from depending on required functionality. The simplest interface is MinimalPaymentData
and it contains the absolute minimal fields necessary to be able to complete a payment flow. And FullPaymentData where
it is possible for the PaymentHandler implementation to control many aspects of the payment flow such as invoice
validity, settlement validity.

Each sub-section describes the different types of PaymentData available.

===== MinimalPaymentData

Contains the minimum fields needed in order to support a payment flow, without possibility to host _payPerRequest_ calls.

.Table Fields in MinimalPaymentData
|===
| Field | Type | Description

| preImageHash
| byte[]
| Unique identifier of a payment in the system and also used in LightningHandler to identify an invoice. Should be
generated by TokenGenerator when creating an order and not set manually.

| orderAmount
| Amount
| The requested amount for payment. This can be either a FiatAmount or CryptoAmount but
  always make sure the systems configured CurrencyConverter supports this currency when converting
  into a currency accepted by the LightningHandler later in the payment flow.

| settled
| boolean
| If related invoice have been settled in full.

|===

For more details see link:javadoc/org/lightningj/paywall/paymenthandler/data/MinimalPaymentData.html[JavaDoc].

===== StandardPaymentData

The StandardPaymentData extends MinimalPaymentData and adds more information about the invoice and the ability
for the PaymentHandler to control invoice validity and settlement validity.


.Table Fields in StandardPaymentData
|===
| Field | Type | Description

| description
| String
| A short description of the payment used in the lightning invoice and might
  be displayed to the end user.

| invoiceAmount
| CryptoAmount
| The amount set in the lightning invoice, this is the same as orderAmount if
  the same currency is used in order as in lightning invoice, otherwise is the currency
  converted before creating the invoice in LightningHandler and the actual invoiced amount
  is specified here.

| invoiceDate
| Instant
| The date the invoice was created in LightningHandler.

| invoiceExpireDate
| Instant
| The date a generated invoice should expire, this value will be used
  when creating invoice in LightningHandler. If null will default invoice validity
  be used to calculate an expire date automatically.

| settledAmount
| CryptoAmount
| The amount that was settled in the LightningHandlers supported crypto currency.
  Should be equal to invoiceAmount if fully settled. Null if invoice isn't settled yet.

| settlementDate
| Instant
| The timestamp the invoice was settled in LightningHandler. Null if not settled yet.

| settlementDuration
| Duration
| The settlement duration indicates how long time a generated settlement should be valid. If
  not set will a default settlement value be used. In FullPaymentData it is also possible
  to specify an expiration date of an settlement that is used if it's required to set a fixed time when
  the settlement should expire, for example if a settlement should be valid the entire day or month.
  _If settlement expire date is set it has precedence over settlementDuration._
  *Important:* Data in this field is only set to instruct the settlement token generator of expiration date.
  the actual settlement date is not updated in this field.

|===

For more details see link:javadoc/org/lightningj/paywall/paymenthandler/data/StandardPaymentData.html[JavaDoc].

===== PerRequestPaymentData

PerRequestPaymentData is a special interface required when pay per request functionality is used. It adds two flags
that indicate that this payment is payPerRequest and whether the settled call have been executed and cannot be requested
again.

*Important*: The PerRequestPaymentData interface is in itself not enough to support a payment flow. The implementing
class must at least implement MinimalPaymentData with PerRequestPaymentData as an extension.

.Table Fields in StandardPaymentData
|===
| Field | Type | Description

| payPerRequest
| boolean
| Flag indicating that this payment is for one request only. The implementation
  can take the payPerRequest flag from the order request as guidance, but it is the PaymentHandler
  that ultimately decides if payPerRequest should be set.

| executed
| boolean
| True if related request have been executed, is set after successful processing
  of a request and used to indicate that it cannot be processed again.

|===

For more details see link:javadoc/org/lightningj/paywall/paymenthandler/data/PerRequestPaymentData.html[JavaDoc].

===== FullPaymentData

The FullPaymentData extends both StandardPaymentData and PerRequestPaymentData and adds fields to store
the actual bolt11Invoice and possiblity to specify exact dates for settlement validity, for use cases when
paying for instance for a monthly subscription for a service and want the settlement token to be valid for exactly
those dates.

.Table Fields in FullPaymentData
|===
| Field | Type | Description

| bolt11Invoice
| String
| The bolt11 lightning invoice displayed to the end user before paying and invoice.

| settlementValidFrom
| Instant
| The valid from timestamp used in generated settlement tokens. If null is no valid from used, only validUntil.

| settlementExpireDate
| Instant
| The settlement expire date sets the timestamp when a generated settlement token should expire. If
  not set will a settlementDuration be used, and if that is also null will default duration be set.
  This field is useful if a settlement should be valid the entire day or month. _If settlement expire date is set it has
  precedence over settlementDuration._
  *Important:* Data in this field is only set to instruct the settlement token generator of expiration date.
  The actual settlement date is not updated in this field.

|===

For more details see link:javadoc/org/lightningj/paywall/paymenthandler/data/FullPaymentData.html[JavaDoc].

=== @PaymentRequired Annotation

Another of the main components of the framework is the @PaymentRequired annotation used to
mark that a service requires payment and initiates a new payment flow if needed.

Currently are only Spring REST Controllers (Annotated with @RestController) supported but other
types of services will be supported in the future.

==== Available @PaymentRequired Parameters

The @PaymentRequired annotation can be customized to create order request information to
the payment handler in various ways. See table below for a full list of available parameters.

.Table Available PaymentRequired Parameters
|===
| Parameters | Required | Default Value | Description

| articleId
| true, see description
| ""
| Determines the type of order that should be generated, used by PaymentHandler to determine order amount depending
  on article an units. (Required if not a custom OrderRequestGenerator is specified).

| units
| false
| 1
| The number of units for given article number.

| payPerRequest
| false
| false
| If payment is valid for one request only. If not will the settlement be valid for multiple request
  over a specified time period.

| orderRequestGenerator
| false
| DefaultOrderRequestGenerator.class
| Possibility to specify a custom order request generator, instead of the default one using
  the articleId and units to request an order. See section <<orderrequestgeneratorparameter, Order Request Generator Parameter>> for details.

| requestPolicy
| false
| WITH_BODY
| Defines what data in HTTP request that is considered relevant for determining a unique payment.
  See section <<requestpolicyparameter, Request Policy Parameter>> for details.

| customPolicy
| false
| NoCustomRequestPolicy.class
| The custom class if none of the predefined request policy types isn't applicable and a custom implementation is necessary.

| paymentOptions
| false
| Empty list
| Set of custom extra options sent to payment handler when creating an order for an invoice. Each value should
  be of class org.lightningj.paywall.annotations.vo.PaymentOption that have two fields, _option_ which acts as a key and _value_ that contains
  the actual value.

|===

==== Examples of @PaymentRequired Annotations

The @PaymentRequired annotation can be placed on either the method or class level. If placed before
the class declaration is all methods paywalled with the same parameters.

Below is an example of a pay walled method where a payment request request is initiated with article id "abc123"
sent the payment handler to create an order for.

[source, java]
-----------------------------------
@RestController
public class Poc1RestController {

    private static final String template = "PocService1, %s!";
    private final AtomicLong counter = new AtomicLong();

    @PaymentRequired(articleId = "abc123")
    @RequestMapping("/poc1")
    public PocResult poc1(@RequestParam(value="name", defaultValue="Poc1") String name) {
        return new PocResult(counter.incrementAndGet(),
                String.format(template, name));
    }
}
-----------------------------------

If payment should be done per-request and not for a specified time add a payPerRequest
parameter.

[source, java]
-----------------------------------
@RestController
public class Poc1RestController {

    private static final String template = "PocService1, %s!";
    private final AtomicLong counter = new AtomicLong();

    @PaymentRequired(articleId = "abc123", payPerRequest = true)
    @RequestMapping("/poc1")
    public PocResult poc1(@RequestParam(value="name", defaultValue="Poc1") String name) {
        return new PocResult(counter.incrementAndGet(),
                String.format(template, name));
    }
}
-----------------------------------

If all methods should be pay walled in a class with the same parameters add the annotation
before the class declaration.

[source, java]
-----------------------------------
@PaymentRequired(articleId = "abc456")
@RestController
public class Poc1RestController {

    private static final String template = "PocService1, %s!";
    private final AtomicLong counter = new AtomicLong();

    @RequestMapping("/poc1")
    public PocResult poc1(@RequestParam(value="name", defaultValue="Poc1") String name) {
        return new PocResult(counter.incrementAndGet(),
                String.format(template, name));
    }
}
-----------------------------------

[[requestpolicyparameter]]
==== The Request Policy Parameter

The request policy is in-charge of calculating a cryptographic hash of all significant data for
a given payment flow. This is used to determine if a given settlement is valid for a related request.

For example if a service should require payment for access to a given REST WebService for a given amount of time
it should specify URL_AND_METHOD and all types of requests to that URL and METHOD will be allowed
until the related settlement expires (given that _payPerRequest_ is set to false). What happens under the hood is that
the URL and METHOD in the original request was included in the cryptographic hash and no other data. After successful
payment and when the same request is snet again will the new requests URL and HTTP method be matched against the
original one.

There exists a set of defined types of request policies that calculate the unique request
from a given set of data.

.Table Available Pre-defined Request Policy Options
|===
| Option | Description

| URL_AND_METHOD
| Policy that checks the URL and Method of a request.

| URL_METHOD_AND_PARAMETERS
| Policy that checks the URL and Method and all parameters of a request.

| WITH_BODY
| Policy that checks the URL, Method, all parameters and full body data of a HTTP request.

| CUSTOM
| Custom implementation of calculating significant request data.

|===

===== Creating a Custom Request Policy

To create a custom request policy, create a class that implements _org.lightningj.paywall.requestpolicy.RequestPolicy_.
It contains one required method significantRequestDataDigest that calculates a request.

The RequestPolicy interface have the following method defined.

[source, java]
-----------------------------------
public interface RequestPolicy {

    /**
     * Method in charge of generating a digest
     * of all significant data in a request that is needed
     * to determine that the call is same that is invoiced
     *
     * @param request the cachable http servlet request to aggregate request data for.
     * @return a RequestData containing a secure cryptographic digest of all significant request data.
     *
     * @throws IllegalArgumentException if supplied request contained invalid data.
     * @throws IOException if i/o related problems occurred reading the request data.
     * @throws InternalErrorException if internal errors occurred reading the request data.
     */
    RequestData significantRequestDataDigest(CachableHttpServletRequest request) throws IllegalArgumentException, IOException, InternalErrorException;
}
-----------------------------------

A tip is to aggregate all data required in a _ByteArrayOutputStream_ and the create the cryptographic hash value
with the _DigestUtils.sha256(baos.toByteArray())_ help method.

[[orderrequestgeneratorparameter]]
==== The Order Request Generator Parameter

By default is an OrderRequest generated to the PaymentHandler containing and article id, number of units, the
payPerRequest flag and the list of paymentOptions. But it is possible the create a custom OrderRequestGenerator
for specific purposes.

One use-case for creating a custom order request generator would be if the article Id or payment options should
be decided dynamically depending on data in the http request, such as body json data, instead of static data from
the @PaymentRequired annotation.

===== Creating a Custom Order Request Generator

To create a custom order generator create a class implementing _org.lightningj.paywall.orderrequestgenerator.OrderRequestGenerator_
that contains one method that should generate a new OrderRequest object from the related PaymentRequired annotation
and HTTP Request object.

[source, java]
-----------------------------------
public interface OrderRequestGenerator {

    /**
     * Method that should populate a new OrderRequest to initiate a
     * payment flow using the PaymentRequired annotation and the
     * related HTTP request.
     * @param paymentRequired the related annotation.
     * @param request the HTTP request related to the call.
     * @return a new OrderRequest.
     * @throws IllegalArgumentException if user supplied data was invalid to generate order request.
     * @throws InternalErrorException if problem occurred generated order request data due to internal miss configuration.
     */
    OrderRequest generate(PaymentRequired paymentRequired, CachableHttpServletRequest request) throws IllegalArgumentException, InternalErrorException;
}
-----------------------------------

=== Payment Flows

The framework is designed to work in different system configurations. It not always desirable for
all micro services to have a direct connection with a lightning node but would like to centralise
this functionality to a central system handling the payment and the actual the paywalled service just
redirects the user to the central payment server until a settlement token have been issued and the requester
is redirected back to the original system.

Currently is only one payment flow supported, the _local payment flow_, but others will be added in the future.

==== Local Payment Flow

The default, and currently only payment flow available, is the _local payment flow_. It's used when
the same system have all paywall components in same system (CheckSettlement controller, WebSocket Service,
LightningHandler etc) and have a direct connection with a lightning node.

Below is a flow chart describing all the steps in the local payment flow in detail. The blue boxes
indicate components that is a part of the target application, the rest is part of the Paywall framework.

.Flow Chart of Payment Interceptor using Local Payment Flow.
image::images/FlowDiagram-1-3-PaywallInterceptor.png[align="center"]

1.1 PaywallInterceptor intercept the request:: This component is a part of the _paywall-spring_ component and is
configured to parse all incoming request

1.2 RestController in target application:: The PaywallInterceptor lookup if target controller contains a
@PaymentRequired annotation. If that is the case and no valid settlement token exists in the HTTP header is a new
Payment Flow initiated.

1.3 RequestPolicy Bean generates significant data:: The request policy type is fetched up from the @PaymentRequired
annotation. And then is the significant data from the request calculated.

1.4 OrderRequestGenerator generates a OrderRequest:: The order request generator is fetched from
the @PaymentRequired annotation. And a order request, usually article id and units, is created.

1.5 TokenGenerator generates PreImageData:: The token generator bean generates a random preImage and preImageHash that
is used to uniquely identify the payment flow and use in the lightning invoice.

1.6 PaymentHandler is called to generate an Order:: The payment handler is called to create a new PaymentData which is
used to create and keep track of an invoice. This is done by calling the method
 _PaymentData newPaymentData(byte[] preImageHash, OrderRequest orderRequest)_ that needs to be implemented by the target
application.

1.7 CurrencyConverter converts amount to used crypto currency:: The defined CurrencyConverter is called to optionally
convert the amount in the Order to the crypto amount used by the LightningHandler. By default is no conversion
performed and the payment handler is required to create orders with amount in CryptoAmount (i.e BTC).

1.8 LightningHandler is called to create a lightning invoice:: The configured LightningHandler is called
to create an invoice for the related payment. The LightningHandler also subscribes to settlement and updates the
PaymentHandler asynchronously using an event bus.

1.9 TokenGenerator generates Invoice JWT Token:: The token generator generates a signed and encrypted JWT (Java Web Token)
of type _invoice_ used to certify the requester as _owner_ of this payment flow and used when checking settlement.

Finally will the PaywallInterceptor generate a <<invoicejson, Invoice JSON Data structure>> and return it with HTTP
status code 402.

The next step in the flow is for the requester to check settlement. This can be done in two way either
by polling a Check Settlement REST API, or by subscribing to a pushed settlement messsage
over a WebSocket (used the the Javascript library by default). The flow diagram describes the inner workings of
the Check Settlement Controller.

.Flow Chart of Check Settlement Controller Logic in Local Payment Flow.
image::images/FlowDiagram-2-CheckSettlement.png[align="center"]

2.1 Check Settlement Controller:: A HTTP GET Request to check payment status. The controller
fetches for Invoice HTTP parameter _pwir_ from the request URL.

2.2 TokenGenerator parses the Invoice Token:: Token Generator parses and validates the JWT and extracts
the preImageHash.

2.3 The PaymentHandler is used to lookup the related PaymentData:: The PaymentHandler's
_PaymentData findPaymentData(byte[] preImageHash)_ is called (that needs to be implemented by the target application)
to look up settlement status.

If the related PaymentData is marked as settled is 2.4 called otherwise is an empty
<<settlementjson, Settlement JSON Data Structure>> returned with only the field _settled_ set to _false_.

2.4 Token Generator generates a Settlement Token:: TokenGenerator generates an encrypted
and signed JWT of type _settlement_. Finally is a populated  <<settlementjson, Settlement JSON Data Structure>>
returned with all fields set.

The third step in the payment flow is for the request to call the target API again, this time with
the settlement token set as HTTP Header with name _Payment_. This step is displayed in the first flow chart.

3.1 The PaywallInterceptor inspects the request again:: This time it determines that settlement token
exists and starts with verification of payment.

3.2 TokenGenerator parses the Settlement Token:: The settlement token is parsed and validated.
It also checks if related payment is payPerRequest and if that is the case is step 3.3 called.

3.3 PaymentHandler checks if request already have been executed:: The PaymentHandler is called using the
_PaymentData findPaymentData(byte[] preImageHash)_ method to verify that the request haven't already been processed.

3.4 RequestPolicy Bean generates significant data of new request:: The significant data is calculated again.

3.5 PaywallInterceptor calls paywalled controller:: If significant data matches with data in settlement token will the
PaywallInterceptor let the request go through to the underlying controller.

3.6 After the Target API have processed the request:: If the payment flow is of type _payPerRequest_ is PaymentHandler's
method _void updatePaymentData(PaymentEventType type, PaymentData paymentData, LightningHandlerContext context)_
called with PaymentEventType set to _PaymentEventType.REQUEST_EXECUTED_.

Finally it the response generated by the target API returned to the requester.

=== Customizing Paywall Components

Most of the components used in the Paywall framework can be customized by implementing the related interface
or overriding existing classes. This section details how to customize some of them.

==== Custom CurrencyConverter

A CurrencyConverter is in charge of converting the Amount specified in an Order created by the PaymentHandler
into the Amount that should be used in the Lightning invoice. One use-case is if the PaymentHandler returns the amount
in FIAT USD and the LightningHandler requires BTC. Then a CurrencyConverter is needed to convert the amount.

By default is _SameCryptoCurrencyConverter_ used which doesn't do any conversion. It is assumed the PaymentHandler will
return the Amount in the cryptocurrency used by the LightningHandler (i.e. BTC).

To customize, implement the interface _org.lightningj.paywall.currencyconverter.CurrencyConverter_ that has one method
_CryptoAmount convert(Amount amount)_ that needs to be implemented. See
link:javadoc/org/lightningj/paywall/currencyconverter/CurrencyConverter.html[JavaDoc] for details.

==== Custom LightningHandler

A LightningHandler is in charge of connecting to a lightning node and create and subscribe to invoices. There exists
one LND implementation in paywall-core (actually two classes Base and Simple) and one extension in paywall-spring adding
Spring related functionality.

.Table Available PaymentRequired Parameters
|===
| LND Implementation Class | Description | JavaDoc Link

| BaseLNDLightningHandler
| Base implementation of LND Lightning Handler handling the methods for generateInvoice, lookupInvoice and invoice
subscribing. See SimpleBaseLNDLightningHandler that manages APIs, opening/closing connection. Extends this if custom
management of LND APIs should be done, otherwise use SimpleBaseLNDLightningHandler.
| link:javadoc/org/lightningj/paywall/lightninghandler/lnd/BaseLNDLightningHandler.html[JavaDoc]

| SimpleBaseLNDLightningHandler
| Extension of BaseLNDLightningHandler that also manages APIs and opening/closing connection. Implementing classes only
need to give host,port, path to TLS cert and macaroon.
| link:javadoc/org/lightningj/paywall/lightninghandler/lnd/SimpleBaseLNDLightningHandler.html[JavaDoc]

| SpringLNDLightningHandler
| Spring implementation of LND Lightning Handler.
| link:javadoc/org/lightningj/paywall/lightninghandler/lnd/SpringLNDLightningHandler.html[JavaDoc]

|===

To implement a custom LightningHandler implement the interface _org.lightningj.paywall.lightninghandler.LightningHandler_. See
link:javadoc/org/lightningj/paywall/lightninghandler/LightningHandler.html[JavaDoc] for details.

==== Custom KeyManager

A KeyManager is in-charge of maintaining cryptographic keys with in the system. There exists two types of
key managers, SymmetricKeyManager managing symmetric keys
(link:javadoc/org/lightningj/paywall/keymgmt/SymmetricKeyManager.html[JavaDoc]), and AsymmetricKeyManager
(link:javadoc/org/lightningj/paywall/keymgmt/AsymmetricKeyManager.html[JavaDoc]) managing asymmetric keys.

Asymmetric keys is used in payment flows requiring multiple systems where trust needs to be set up between them.

The default implementation is DefaultFileKeyManager that implements both SymmetricKeyManager and AsymmetricKeyManager and
stores the keys on local disk, encrypted by a passphrase and generates the needed keys automatically when needed.

==== Custom TokenGenerator

The TokenGenerator is responsible for generating signed and encrypted JWT Tokens and PreImageData. There exists two
implementations of TokenGenerator, SymmetricKeyTokenGenerator using symmetric key manager and used in the local payment
flow, and AsymmetricKeyTokenGenerator using asymmetric keys for payment flows requiring setting up trust between
different systems.

There are three type of JST tokens defined in table below. The local payment flow only uses
the Invoice and Settlement tokens.

.Table Available PaymentRequired Parameters
|===
| JWT Token Type | Description | Contains Data

| Payment
| Used in distributed payment flows where JWT token contains Order information to create a PaymentData.
| OrderRequest, Order, RequestData

| Invoice
| Contains information about a lightning invoice, used when checking for settlement to prove ownership of the
payment flow.
| OrderRequest, MinimalInvoice, RequestData

| Settlement
| Contains information that an invoice have been settled, including how for how long the settlement
is valid.
| OrderRequest, Settlement, RequestData
|===

To create a customized TokenGenerator implement the interface _org.lightningj.paywall.tokengenerator.TokenGenerator_
See link:javadoc/org/lightningj/paywall/tokengenerator/TokenGenerator.html[JavaDoc] for details.